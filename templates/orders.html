<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>üçΩÔ∏èOnline Canteen ‚Äî My Orders</title>
  <link rel="stylesheet" href="/static/style.css">
  <link rel="stylesheet" href="/static/orders.css">
</head>
<body>
  <header class="topbar">
    <div class="brand">üçΩÔ∏è Online Canteen</div>
    <nav class="nav">
      <a href="order.html">Menu</a>
      <a href="orders.html" class="active">My Orders</a>
      <a href="profile.html">Profile</a>
      <a href="#" onclick="logoutUser()">Logout</a>
    </nav>
  </header>

  <!-- Notification Container -->
  <div id="notificationContainer" style="position: fixed; top: 80px; right: 20px; z-index: 10000; max-width: 400px;"></div>

  <main class="container">
    <h2 class="headline">My Orders <span id="chatNotificationBadge" style="display:none; background: #e74c3c; color: white; padding: 4px 10px; border-radius: 12px; font-size: 0.85rem; margin-left: 8px;">0</span></h2>
    
    <!-- Refund Notification Banner -->
    <div id="refundNotificationBanner" style="display: none; margin-bottom: 20px; padding: 16px; background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <div style="flex: 1;">
          <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 4px;">üí∞ Refund Processed!</div>
          <div style="font-size: 0.9rem; opacity: 0.95;" id="refundNotificationMessage"></div>
        </div>
        <button onclick="document.getElementById('refundNotificationBanner').style.display='none'" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 18px; font-weight: bold;">√ó</button>
      </div>
    </div>
    
    <div id="ordersList" class="orders-list"></div>
    <div id="noOrders" class="muted center" style="display:none">You have no orders yet.</div>
  </main>

  <script>
    // Load script.js with cache-busting and wait for it to load
    (function() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = '/static/script.js?v=' + Date.now();
        script.onerror = function() {
          console.error('Failed to load script.js');
          reject(new Error('Failed to load script.js'));
        };
        script.onload = function() {
          // Wait a bit more to ensure all functions are defined
          setTimeout(() => {
            if (typeof getCurrent === 'function' && typeof renderUserOrders === 'function') {
              resolve();
            } else {
              // Retry check
              setTimeout(() => {
                if (typeof getCurrent === 'function' && typeof renderUserOrders === 'function') {
                  resolve();
                } else {
                  console.warn('Script loaded but functions not available yet');
                  resolve(); // Continue anyway
                }
              }, 500);
            }
          }, 100);
        };
        document.head.appendChild(script);
      });
    })().then(() => {
      // Script loaded, now run the inline scripts
      initializeOrdersPage();
    }).catch((error) => {
      console.error('Error loading script.js:', error);
      alert('Error: Failed to load required scripts. Please refresh the page.');
    });
    
    // Define initialization function that will be called after script.js loads
    function initializeOrdersPage() {
      let userOrderPollInterval = null;
      
      // Check for order updates in real-time
      async function checkUserOrderUpdates() {
        try {
          if (typeof renderUserOrders === 'function') {
            await renderUserOrders(); // This will update sequential numbers
          }
        } catch(error) {
          console.error('Error checking order updates:', error);
        }
      }
      
      // Start polling for order updates
      function startUserOrderPolling() {
        // Poll every 8 seconds for real-time updates (optimized for smoothness)
        if (!userOrderPollInterval) {
          userOrderPollInterval = setInterval(checkUserOrderUpdates, 8000);
        }
      }
      
      // Stop polling
      function stopUserOrderPolling() {
        if (userOrderPollInterval) {
          clearInterval(userOrderPollInterval);
          userOrderPollInterval = null;
        }
      }
      
      // Check for unread chat messages
      async function checkUnreadChatMessages() {
      try {
        if (typeof getCurrent !== 'function') {
          console.warn('getCurrent not available yet');
          return;
        }
        const currentUser = getCurrent();
        if (!currentUser) return;
        
        const response = await fetch(`${API_BASE}/orders?t=${Date.now()}`);
        const allOrders = await response.json();
        const myOrders = allOrders.filter(o => o.user_id === currentUser.id);
        
        let totalUnread = 0;
        const newMessages = []; // Track new messages for notifications
        
        for (const order of myOrders) {
          try {
            const messagesResponse = await fetch(`${API_BASE}/orders/${order.id}/messages`);
            if (messagesResponse.ok) {
              const messages = await messagesResponse.json();
              if (messages && messages.length > 0) {
                // Filter unread admin messages
                const unreadMessages = messages.filter(m => 
                  m.sender_role === 'admin' && !m.is_read
                );
                totalUnread += unreadMessages.length;
                
                // Check for new messages (not in lastKnownUserMessageIds)
                unreadMessages.forEach(msg => {
                  const msgId = msg.id || `${order.id}-${msg.created_at}`;
                  if (!lastKnownUserMessageIds.has(msgId)) {
                    // New message detected
                    newMessages.push({
                      message: msg,
                      order: order
                    });
                    lastKnownUserMessageIds.add(msgId);
                  }
                });
                
                // Also add all message IDs to the set (for tracking)
                messages.forEach(msg => {
                  const msgId = msg.id || `${order.id}-${msg.created_at}`;
                  lastKnownUserMessageIds.add(msgId);
                });
              }
            }
          } catch (err) {
            // Skip errors
          }
        }
        
        // Update badge
        const badge = document.getElementById('chatNotificationBadge');
        if (badge) {
          if (totalUnread > 0) {
            badge.textContent = totalUnread;
            badge.style.display = 'inline-block';
            badge.style.animation = 'pulse 0.5s ease-in-out 3';
          } else {
            badge.style.display = 'none';
            badge.style.animation = '';
          }
        }
        
        // Show notifications for new messages (only if not initial load)
        // Initial load: lastKnownUserMessageIds is empty or only contains the new messages
        const isInitialLoad = lastKnownUserMessageIds.size <= newMessages.length;
        if (newMessages.length > 0 && !isInitialLoad) {
          newMessages.forEach(({message, order}) => {
            showUserMessageNotification(message, order);
          });
        }
      } catch(error) {
        console.error('Error checking unread messages:', error);
      }
    }
    
    let chatNotificationInterval = null;
    let lastKnownUserMessageIds = new Set(); // Track known message IDs to detect new ones
    
    // Show message notification for users
    function showUserMessageNotification(message, order) {
      const container = document.getElementById('notificationContainer');
      if (!container) return;

      const notification = document.createElement('div');
      notification.className = 'message-notification';
      notification.style.cssText = `
        background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
        color: white;
        padding: 16px 20px;
        border-radius: 12px;
        margin-bottom: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        animation: slideInRight 0.3s ease-out;
        cursor: pointer;
        border-left: 4px solid #FFD700;
      `;

      const messageText = (message.message || '').substring(0, 100);
      const orderNumber = order.id;
      
      notification.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start; gap: 12px;">
          <div style="flex: 1;">
            <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 6px; display: flex; align-items: center; gap: 8px;">
              üí¨ New Message from Admin
            </div>
            <div style="font-size: 0.9rem; opacity: 0.95; margin-bottom: 4px;">
              Order #${orderNumber}
            </div>
            <div style="font-size: 0.85rem; opacity: 0.85; margin-top: 4px;">
              ${messageText}${messageText.length >= 100 ? '...' : ''}
            </div>
          </div>
          <button onclick="this.parentElement.parentElement.remove();" 
                  style="background: rgba(255,255,255,0.2); border: none; color: white; 
                         width: 28px; height: 28px; border-radius: 50%; cursor: pointer; 
                         font-size: 18px; line-height: 1; padding: 0;">√ó</button>
        </div>
      `;

      // Click to dismiss
      notification.addEventListener('click', (e) => {
        if (e.target.tagName === 'BUTTON') {
          notification.remove();
        }
      });

      container.appendChild(notification);

      // Play sound if available
      if (typeof createNotificationSound === 'function') {
        createNotificationSound();
      }

      // Auto-remove after 8 seconds
      setTimeout(() => {
        if (notification.parentElement) {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => notification.remove(), 300);
        }
        }, 8000);
      }
      
      function startChatNotificationPolling() {
        checkUnreadChatMessages();
        chatNotificationInterval = setInterval(checkUnreadChatMessages, 5000);
      }
      
      function stopChatNotificationPolling() {
        if (chatNotificationInterval) {
          clearInterval(chatNotificationInterval);
          chatNotificationInterval = null;
        }
      }
    
      // Check authentication - use fallback to avoid ensureLoggedIn issues
      let isAuthenticated = false;
      
      if (typeof getCurrent === 'function') {
        try {
          const currentUser = getCurrent();
          if (currentUser && currentUser.role === 'user') {
            isAuthenticated = true;
          }
        } catch(e) {
          console.warn('getCurrent error:', e);
        }
      }
      
      if (!isAuthenticated) {
        // Fallback: check localStorage directly
        try {
          const stored = localStorage.getItem('canteen_current_v2');
          if (stored) {
            const currentUser = JSON.parse(stored);
            if (currentUser && currentUser.role === 'user') {
              isAuthenticated = true;
            }
          }
        } catch(e) {
          console.error('Error checking authentication:', e);
        }
      }
      
      if (!isAuthenticated) {
        alert('Please login first');
        window.location.href = 'index.html';
        return;
      }
      
      // Try to call ensureLoggedIn if available (but don't fail if it's not)
      if (typeof ensureLoggedIn === 'function') {
        try {
          ensureLoggedIn('user'); // This will check and show approval notification
        } catch(e) {
          console.warn('ensureLoggedIn error (continuing anyway):', e);
        }
      }
      // Force reload orders when page loads (wait for script to be ready)
      console.log('[ORDERS] Initializing orders page...');
      if (typeof renderUserOrders === 'function') {
        console.log('[ORDERS] renderUserOrders is available, calling it...');
        renderUserOrders().catch(err => {
          console.error('[ORDERS] Error calling renderUserOrders:', err);
        });
      } else {
        console.warn('[ORDERS] renderUserOrders not available yet, will retry...');
        setTimeout(() => {
          if (typeof renderUserOrders === 'function') {
            console.log('[ORDERS] renderUserOrders now available, calling it...');
            renderUserOrders().catch(err => {
              console.error('[ORDERS] Error calling renderUserOrders:', err);
            });
          } else {
            console.error('[ORDERS] renderUserOrders still not available after wait');
            // Try to manually load orders as fallback
            const list = document.getElementById('ordersList');
            if (list) {
              list.innerHTML = '<p class="muted">Please refresh the page to load orders.</p>';
            }
          }
        }, 1000); // Increased timeout to 1 second
      }
      // Start real-time polling
      if (typeof startUserOrderPolling === 'function') {
        startUserOrderPolling();
      }
      // Check for unread chat messages
      if (typeof checkUnreadChatMessages === 'function') {
        checkUnreadChatMessages();
      }
      if (typeof startChatNotificationPolling === 'function') {
        startChatNotificationPolling();
      }
      // Define checkRefundNotifications function (before calling it)
      async function checkRefundNotifications() {
        try {
          if (typeof getCurrent !== 'function') {
            console.warn('getCurrent not available yet');
            return;
          }
          const currentUser = getCurrent();
          if (!currentUser) return;
          
          const response = await fetch(`${API_BASE}/orders?t=${Date.now()}`);
          const allOrders = await response.json();
          const myOrders = allOrders.filter(o => o.user_id === currentUser.id);
        
          // Check for refunded orders
          const refundedOrders = myOrders.filter(o => o.refund_status === 'refunded');
          
          if (refundedOrders.length > 0) {
            // Check if notification was already shown (using localStorage)
            const lastRefundCheck = localStorage.getItem('lastRefundCheck') || '0';
            const newRefunded = refundedOrders.filter(o => {
              // Use created_at as fallback if updated_at doesn't exist
              const orderDate = new Date(o.updated_at || o.created_at || Date.now()).getTime();
              return orderDate > parseInt(lastRefundCheck);
            });
            
            if (newRefunded.length > 0) {
              // Show notification for the most recent refund
              const latestRefund = newRefunded.sort((a, b) => {
                const dateA = new Date(a.updated_at || a.created_at || 0).getTime();
                const dateB = new Date(b.updated_at || b.created_at || 0).getTime();
                return dateB - dateA;
              })[0];
              
              const refundAmount = Number(latestRefund.total || 0).toFixed(2);
              const orderNumberMap = getUserOrderNumberMap ? getUserOrderNumberMap() : {};
              const sequentialNumber = orderNumberMap[latestRefund.id] || latestRefund.id;
              const banner = document.getElementById('refundNotificationBanner');
              const message = document.getElementById('refundNotificationMessage');
              
              if (banner && message) {
                message.textContent = `Your refund of ‚Ç±${refundAmount} for Order #${sequentialNumber} has been processed. The amount will be credited to your account within 3-5 business days.`;
                banner.style.display = 'block';
                banner.style.animation = 'slideInRight 0.3s ease-out';
                
                // Update last check time
                const now = Date.now();
                localStorage.setItem('lastRefundCheck', now.toString());
                
                // Auto-hide after 15 seconds
                setTimeout(() => {
                  if (banner && banner.style.display !== 'none') {
                    banner.style.animation = 'fadeOut 0.5s ease-out';
                    setTimeout(() => {
                      if (banner) banner.style.display = 'none';
                    }, 500);
                  }
                }, 15000);
              }
            }
          }
        } catch (error) {
          console.error('Error checking refund notifications:', error);
        }
      }
      
      // Call checkRefundNotifications after defining it
      checkRefundNotifications();
      
      // Also reload when page becomes visible (handles tab switching, back button)
      document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        if (typeof renderUserOrders === 'function') {
          renderUserOrders();
        }
        if (typeof startUserOrderPolling === 'function') {
          startUserOrderPolling();
        }
        if (typeof checkUnreadChatMessages === 'function') {
          checkUnreadChatMessages();
        }
        startChatNotificationPolling();
      } else {
        stopUserOrderPolling();
        stopChatNotificationPolling();
        }
      });
      
      // Reload when page is focused (user switches back to tab)
      window.addEventListener('focus', () => {
      if (typeof renderUserOrders === 'function') {
        renderUserOrders();
      }
      if (typeof startUserOrderPolling === 'function') {
        startUserOrderPolling();
      }
      if (typeof checkUnreadChatMessages === 'function') {
        checkUnreadChatMessages();
      }
      if (typeof startChatNotificationPolling === 'function') {
        startChatNotificationPolling();
      }
      });
      
      // Stop polling when page is hidden (save resources)
      window.addEventListener('blur', () => {
        stopUserOrderPolling();
        stopChatNotificationPolling();
      });
    }
  </script>
</body>
</html>
